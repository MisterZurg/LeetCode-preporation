package main

import "fmt"

func isValidSudoku(board [][]byte) bool {
	// С помощью мапы[число]наличие проверить горизонталь/вертикаль и верстак
	// Строка
	for i := 0; i < 9; i++ {
		vertical := make(map[byte]bool)
		horizontal := make(map[byte]bool)
		//  Столбец
		for j := 0; j < 9; j++ {
			// Если не точка, то чекаем наличие выходим или добавляем
			// Для удобства вынесем значение в переменную
			vert := board[i][j]
			// Вспомогательная ф-ия провеки
			if !notInMap(vert, vertical) {
				return false
			}
			hor := board[j][i]
			if !notInMap(hor, horizontal) {
				return false
			}
		}
	}
	// В этом моменте я наступил на грабли:
	workbench := make(map[int]map[byte]bool)
	// В workbench сейчас map[]
	for i := 0; i < 9; i++ {
		// Инициализируем 9 пустых мап под квадраты
		// map[0:map[] 1:map[] ... 8:map[]]
		workbench[i] = make(map[byte]bool)
	}
	// Верстак нужно проверять только в том случае если мы находимся в его середине
	// 1,1 / 1,4 / 1,7
	// 4,1 / 4,4 / 4,7
	// 7,1 / 7,4 / 7,7
	// Строка Горизонталь
	for i := 0; i < len(board); i++ {
		// Столбец Вертикаль
		for j := 0; j < len(board[i]); j++ {
			// Пропускаем точки
			if board[i][j] == '.' {
				continue
			}
			// i\j| 0 | 1 | 2 |
			//  0 | 0 | 1 | 2 |
			//  1 | 3 | 4 | 5 |
			//  2 | 6 | 7 | 8 |
			boxNumber := ((i / 3) * 3) + j/3
			cellValue := board[i][j]
			if _, ok := workbench[boxNumber][cellValue]; ok {
				return false
			}
			workbench[boxNumber][cellValue] = true
		}
	}
	return true
}

// notInMap это вспомогательная ф-я чека ключа в мапе
func notInMap(elem byte, container map[byte]bool) bool {
	if _, ok := container[elem]; !ok {
		// Пропускаем точки
		if elem != '.' {
			container[elem] = true
		}
		return true
	}
	return false
}

// Only for local testing
func main() {
	testInput()
}

func testInput() {
	//test344 := [][]byte{
	//	{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
	//	{'6', '.', '.', '1', '9', '5', '.', '.', '.'},
	//	{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
	//	{'8', '.', '.', '.', '6', '.', '.', '.', '3'},
	//	{'4', '.', '.', '8', '.', '3', '.', '.', '1'},
	//	{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
	//	{'.', '6', '.', '.', '.', '.', '2', '8', '.'},
	//	{'.', '.', '.', '4', '1', '9', '.', '.', '5'},
	//	{'.', '.', '.', '.', '8', '.', '.', '7', '9'},
	//}
	//fmt.Println("Test 344 - Expected: true / Output", isValidSudoku(test344))
	test473 := [][]byte{
		{'.', '.', '.', '.', '5', '.', '.', '1', '.'},
		{'.', '4', '.', '3', '.', '.', '.', '.', '.'},
		{'.', '.', '.', '.', '.', '3', '.', '.', '1'},

		{'8', '.', '.', '.', '.', '.', '.', '2', '.'},
		{'.', '.', '2', '.', '7', '.', '.', '.', '.'},
		{'.', '1', '5', '.', '.', '.', '.', '.', '.'},

		{'.', '.', '.', '.', '.', '2', '.', '.', '.'},
		{'.', '2', '.', '9', '.', '.', '.', '.', '.'},
		{'.', '.', '4', '.', '.', '.', '.', '.', '.'},
	}
	fmt.Println("Test 497 - Expected: false / Output", isValidSudoku(test473))

	test497 := [][]byte{
		{'.', '.', '.', '.', '.', '.', '5', '.', '.'},
		{'.', '.', '.', '.', '.', '.', '.', '.', '.'},
		{'.', '.', '.', '.', '.', '.', '.', '.', '.'},

		{'9', '3', '.', '.', '2', '.', '4', '.', '.'},
		{'.', '.', '7', '.', '.', '.', '3', '.', '.'},
		{'.', '.', '.', '.', '.', '.', '.', '.', '.'},

		{'.', '.', '.', '3', '4', '.', '.', '.', '.'},
		{'.', '.', '.', '.', '.', '3', '.', '.', '.'},
		{'.', '.', '.', '.', '.', '5', '2', '.', '.'},
	}
	fmt.Println("Test 497 - Expected: false / Output", isValidSudoku(test497))
}
